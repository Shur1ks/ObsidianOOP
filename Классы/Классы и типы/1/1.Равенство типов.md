![[Pasted image 20241026052923.png]]Последняя часть лекции класса будет посвящена связи
классов и их типов.
Вообще в объект нариентированном программировании
класс – это основной способ создания новых типов.
Есть несколько типов, которые встроены язык,
а все остальные типы появляются либо библиотеках,
написали класс.
Теперь уже типу пользоваться, создавать объекты этого класса.
И можно сказать, что то же самое будет, что мы создаем
объекты этого типа.
Библиотеках или ваших собственных программах пишут
эти классы.
Опять создают и новый тип.
Для большинства языков программирования справедливого
отверждения, что тип объекта совпадает с типом класса,
которую он создал.
И типы объектов равны, если они созданы из одного
класса.
В TypeScript есть небольшой нюанс.
Если вы создаете два объекта одного класса, скажем,
ее student, не student, то эти объекты будут иметь
один тип.
Но в TypeScript есть менее строгое с отношения
раненства типов объекта.
В нашем примере у нас student и tutor это два разных
класса.
Соответственно, обычному по это два разных типов.
Однако в TypeScript мы смогли написать константа
Иван не тип tutor, но при этом объект, который мы
у нее поместили.
Сознан из класса student.
При этом TypeScript на такой код не ругается.
С его точки зрения здесь нет проблемы с раненством
типов.
Тип с левой тип справа совпадают.
Как видите, если запустить эту программу, потом распечатать
нашу студенту Ивана, то мы видим, что действительно
по сонке Иван содержится объективу студент.
Почему так происходит?
Потому что TypeScript не является так называемая утивная
типизация.
Это название идет от поговорки с точью выражения.
Что если что-то плавает какую утку и крякает как утка,
то это есть утка, чем бы она на самом деле не был.
Такая TypeScript считает, что если в объекте есть все необходимые
свойства, которые соответствуют типу, то этот объект можно
принять за этот тип.
И поэтому TypeScript без проблем дал записать в переменную
Иван объект, который содержит имя Наем и содержит
еще одно свойство Place.
В чем?
И то и другой стриг, типа String.
То есть именно свой стриг типы совпадают это все, что
необходимо TypeScript, чтобы признать совпадение типов.
Итак, основная мысль, которую нужно вынести из этого
примера, то что TypeScript совпадение или ранство типов
определяется не по имени класса, а по набору свойства.
Имя класса используется для другой.
То есть колокласс это только шаблон для создания объектов,
после того, как мы по классу создали.
Объект дальше он уже сам по себе имеет тип связанной
и не семьям класса с набором свойства.
![[Pasted image 20241026053023.png]]
Ну, немножко уточним, а ранности объектов для классов, которые содержат статический поля.
Вот в класс тютор мы добавили еще одну свойству, не ститут.
Но это свойство, мы сделали статический.
Можно ли в этом случае присваивать ссылку, которая типа тютор, объекты типа стюдут?
Если мы вспомним, что такое статическая свойства, то мы вспомним, что все статические свойства и методы помещаются не в объект,
который является экземпляром класса, а в объект, который является компоненом класса.
На каждый класс задаются один объект, куда помещается все статический.
Ссылка же ссылается на объект экземпляр класс, в котором в объекте типа тютор должен содержаться только свойство на имплейс.
Соответственно, и в этом случае, когда класс отличается статическими полями,
то есть в скрипт не имеет ничего против того, чтобы переменную,
которая ссылается на объект типа тютор, поместить ссылку на объект типа стюдут.
Свои ста совпадают.
